# API Gateway resources

Requirements:

- AWS CLI configured
- User with AmazonAPIGatewayAdministrator grants

If you miss some of the requirements, please check the [main readme](/README.md).

## Let's deploy our first API, a simple Hello World

Our first API will be a Hello World implementation. WOW! HOW ORIGINAL!

### Create the Swagger API definition

Ignoring the _boiler plate_ of the API definition, we will focus on the paths declaration:

```yaml
paths:
  /:
    get:
      consumes:
      - "application/json"
      produces:
      - "application/json"
      responses:
        200:
          description: "200 response"
          schema:
            $ref: "#/definitions/Empty"
      x-amazon-apigateway-integration:
        responses:
          default:
            statusCode: "200"
            responseTemplates:
              application/json: "{ \"message\" : \"Hello world!\" }"
        requestTemplates:
          application/json: "{\"statusCode\": 200}"
        passthroughBehavior: "when_no_match"
        type: "mock"
```

For this example, we only will need the root path `/` implementing `GET` method. 

In this case, the API endpoint will MOCK the response from a server and just reply with a _Hello World_ `json` message and an HTTP `200` status code. You can check this configuration defined in the responses node of the `yaml`.

The full API definition can be found at [Hello World API Swagger configuration](definitions/hello-world.yaml).

### Let's import the API to create a new API Gateway REST API

```bash
aws apigateway import-rest-api --body 'file://definitions/hello-world.yaml'
```

It will return the created REST API Id:

```json
{
    "name": "hello-world",
    "version": "2017-07-16T15:15:20Z",
    "id": "krl6q0xxh0",
    "createdDate": 1500226022
}
```

Now you have the API fully configured and ready to be deployed:

```bash
aws apigateway get-rest-apis
```

```json
{
    "items": [
        {
            "createdDate": 1500226022,
            "id": "krl6q0xxh0",
            "version": "2017-07-16T15:15:20Z",
            "name": "hello-world"
        }
    ]
}
```

### Let's deploy the API

Next step is to deploy the API, this will publish the current version under the endpoint identified by the stage name.

```bash
aws apigateway create-deployment --rest-api-id krl6q0xxh0 --stage-name 'dev'
```

```json
{
    "id": "cmqk1q",
    "createdDate": 1500226617
}
```

And it's done, the API is now deployed and waiting for requests.

The default AWS autogenerated endpoints follows the next pattern:

```perl
https://{restapi_id}.execute-api.{region}.amazonaws.com/{stage_name}/
```

If we replace the variables with our values:

- Region: `eu-west-1`
- REST API Id: `krl6q0xxh0`
- Stage Name: `dev`

We will get our API endpoint and we can check it with curl or a browser:

```bash
curl https://krl6q0xxh0.execute-api.eu-west-1.amazonaws.com/dev
```

And it should respond our Hello World message:

```json
{ "message" : "Hello world!" }
```

### After playing with it, we can remove it using the CLI

Executed the `delete-rest-api` command:

```bash
aws apigateway delete-rest-api --rest-api-id krl6q0xxh0
```

Listing all your REST APIs:

```bash
aws apigateway get-rest-apis
```

Should return again an empty items list:

```json
{
    "items": []
}
```

## Let's work on our second API, a Hello You

This API will be much alike the Hello World but with a twist. This time, the URL will be used as a parameter to personalize the response. 

You can get the full API definition in [Hello You API Swagger configuration](definitions/hello-you.yaml). 

Let's focus again on the paths configuration:

```yaml
paths:
  /{name}:
    get:
      consumes:
      - "application/json"
      produces:
      - "application/json"
      parameters:
      - name: "name"
        in: "path"
        required: true
        type: "string"
      responses:
        200:
          description: "200 response"
          schema:
            $ref: "#/definitions/Empty"
      x-amazon-apigateway-integration:
        responses:
          default:
            statusCode: "200"
            responseTemplates:
              application/json: "{  \"message\" : \"Hello $input.params('name')!\" }"
        requestTemplates:
          application/json: "{\"statusCode\": 200}"
        passthroughBehavior: "when_no_match"
        type: "mock"
```

Now the path contains a `{name}` variable:

```yaml
paths:
  /{name}:
```

That will be captured as path parameter:

```yaml
      parameters:
      - name: "name"
        in: "path"
        required: true
        type: "string"
```

And used in the response to personalize the message:

```yaml
            responseTemplates:
              application/json: "{  \"message\" : \"Hello $input.params('name')!\" }"
```

You can get more information about the available parametrizations in [API Gateway Mapping Template Built-in Functions and Variables](http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html).

The templates uses Apache VTL engine, you can read about the languange in [the reference for the Velocity Template Language (VTL)](http://velocity.apache.org/engine/1.7/vtl-reference.html).


### Let's deploy it

This time, we will go a bit faster:

- Create the REST API with the definition file

```bash
aws apigateway import-rest-api --body 'file://definitions/hello-you.yaml'
```

```json
{
    "name": "hello-you",
    "version": "2017-07-16T15:35:27Z",
    "id": "2kideufka4",
    "createdDate": 1500240051
}
```

- Deploy the API

```bash
aws apigateway create-deployment --rest-api-id 2kideufka4 --stage-name 'dev'
```

```json
{
    "id": "z0fwy1",
    "createdDate": 1500240723
}
```

- Test it

```bash
curl https://2kideufka4.execute-api.eu-west-1.amazonaws.com/dev/Rael
```

```json
{  "message" : "Hello Rael!" }
```

- Finally, after playing with the API, remove it

```bash
aws apigateway delete-rest-api --rest-api-id 2kideufka4
```

- Verify that you don't leave anything behind

```bash
aws apigateway get-rest-apis
```

```json
{
    "items": []
}
```